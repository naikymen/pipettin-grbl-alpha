const getMainHelper = require('./mainHelper');
const mainHelper = getMainHelper();
const util = require('util');

function protocolBuilder () {
  function sort (steps) {
    function compare (a, b) {
      if (a.order < b.order) {
        return -1;
      }
      if (a.order > b.order) {
        return 1;
      }
      return 0;
    }
    return steps.sort(compare);
  }

  let hlp;
  let workspace;

  async function build (ihlp, iworkspace) {
    hlp = ihlp;
    workspace = iworkspace;
    const middleLevelProtocol = {
      'name': (hlp.name || 'noname') + ' ' + new Date().toISOString(),
      'date': new Date(),
      'description': hlp.description || '',
      'meta': 'Generated by protocolBuilder v1.0',
      'workspace': workspace.name,
      'actions': [getHomeAction()]
    };
    console.log('entry', hlp);

    if (!(hlp && hlp.steps && hlp.steps.length)) {
      return middleLevelProtocol;
    }

    const steps = sort(hlp.steps);
    for (let s = 0; s < steps.length; s++) {
      const step = steps[s];
      const actions = buildStep(step);
      if (actions) {
        middleLevelProtocol.actions = middleLevelProtocol.actions.concat(actions);
      }
    }
    middleLevelProtocol.actions.push(getHomeAction());
    console.log('middleLevelProtocol======:');
    console.log(util.inspect(middleLevelProtocol, false, 10));
    return middleLevelProtocol;
  }

  function buildStep (step) {
    const supportedTypes = {
      'SIMPLE_PIPETTIN': buildSimplePipettinStep,
      'WAIT': buildWaitStep,
      'HUMAN': buildHumanStep,
      'COMMENT': buildCommentStep,
      'MIX': buildMixStep
    };

    if (typeof supportedTypes[step.type] === 'function') {
      return supportedTypes[step.type](step);
    }
    console.log('Unsupported Step type.');
    return false;
  }

  function getAvailableSourceAndUpdateIt (sources, volume, multiplexorOrNothing) {
    for (let i = 0; i < sources.length; i++) {
      if (sources[i].content.volume >= volume) {
        // pick from here
        sources[i].content.volume = sources[i].content.volume - volume;
        return {s: sources[i], v: volume};
      } else if (sources[i].content.volume > 0) {
        if (multiplexorOrNothing) {
          const howMany = sources[i].content.volume / multiplexorOrNothing;
          const roundHowMany = parseInt(howMany, 10);
          if (roundHowMany === 0) {
            // chau, no me sirve
            sources.splice(i, 1);
          } else {
            const currectVol = multiplexorOrNothing * roundHowMany;
            sources[i].content.volume = sources[i].content.volume - currectVol;
            return {s: sources[i], v: currectVol};
          }
        } else {
          const currectVol = sources[i].content.volume;
          sources[i].content.volume = 0;
          return {s: sources[i], v: currectVol};
        }
      } else {
        sources.splice(i, 1);
      }
    }
    return false;
  }

  function updateTargetVolume (target, volume) {
    const content = mainHelper.getContentsInWorkspace(workspace, target.item, 'name', target.content.name);
    if (content && content.length) {
      content[0].content.volume += volume;
    }
  }

  function computeReTag (definition, source) {
    if (definition.target.addTag && definition.target.addTag.value) {
      let newTag = definition.target.addTag.value.replace(/\{\{source\.name\}\}/g, source.content.name);
      newTag = newTag.replace(/\{\{source\.position\}\}/g, `${source.content.position.col}:${source.content.position.row}`);
      return newTag;
    }
    return '';
  }

  function buildSimplePipettinStep (step) {
    console.log('step', step);
    if (!step.definition) {
      console.log('No definition in step.');
      return false;
    }
    if (!step.definition.source) {
      console.log('No source in step.');
      return false;
    }
    if (step.definition.source.treatAs === 'same') {
      return buildSimplePipettinStepTreatSame(step);
    }
    return buildSimplePippetinStepTreatEach(step);
  }

  function buildSimplePipettinStepTreatSame (step) {
    // use as same.
    const actions = [];
    const sources = mainHelper.getContentsInWorkspace(workspace, step.definition.source.item, step.definition.source.by, step.definition.source.value);
    console.log('===sources', sources);
    if (!sources.length) {
      console.log('No matching sources in step.');
      return false;
    }
    const targets = mainHelper.getContentsInWorkspace(workspace, step.definition.target.item, step.definition.target.by, step.definition.target.value);
    console.log('===targets', targets);
    if (!targets.length) {
      console.log('No matching targets in step.');
      return false;
    }
    if (!step.definition.volume || !step.definition.volume.type) {
      console.log('No volume type in step.');
      return false;
    }
    let volumeForEachTarget = step.definition.volume.value; // fixed_each
    if (step.definition.volume.type === 'for_each_target_tag') { // (for_each_target_with_tag)
      const volumeMultipler = mainHelper.getContentsInWorkspace(workspace, '', 'tag', step.definition.volume.tag).length;
      volumeForEachTarget = volumeMultipler * step.definition.volume.value;
    } else if (step.definition.volume.type === 'fixed_total') {
      volumeForEachTarget = step.definition.volume.value / targets.length;
    }

    const pippetingMode = step.definition.tip.mode;
    const tipVolume = mainHelper.getTipVolume(workspace, step.definition.tip.item);
    if (!tipVolume) {
      console.log('No max volume defined in tip rack.');
      return false;
    }
    const travelsForEachTarget = Math.ceil(volumeForEachTarget / tipVolume);
    console.log('==volumeForEachTarget==', volumeForEachTarget);
    console.log('==travelsForEachTarget==', travelsForEachTarget);

    // llenar el tip y repartir chorritos con el mismo tip
    if ((pippetingMode === 'isolated_source_only' || pippetingMode === 'reuse') && volumeForEachTarget < tipVolume) {
      // how many targets can I feed?
      let canFeed = parseInt(tipVolume / volumeForEachTarget, 10);
      let needTip = true;
      while (targets.length) {
        if (needTip) {
          actions.push(getPickTipAction(step.definition.tip.item));
        }
        if (canFeed > targets.length) {
          canFeed = targets.length;
        }
        const pic = canFeed * volumeForEachTarget;
        const usingSource = getAvailableSourceAndUpdateIt(sources, pic, volumeForEachTarget);
        console.log(usingSource);
        if (!usingSource) {
          console.log('No source available to pick required liquid.');
          return false;
        }
        actions.push(getLoadLiquidAction(usingSource.s.item, 'name', usingSource.s.content.name, usingSource.v));
        let travels = usingSource.v / volumeForEachTarget;
        if (travels > targets.length) {
          travels = targets.length;
        }
        for (let t = 0; t < travels; t++) {
          const target = targets.pop();
          actions.push(getDropLiquidAction(target.item, 'name', target.content.name, volumeForEachTarget));
          updateTargetVolume(target, volumeForEachTarget);
        }
        if (pippetingMode === 'isolated_source_only') {
          actions.push(getDiscardTipAction(step.definition.tip.discardItem));
          needTip = true;
        } else {
          needTip = false;
        }
      }
      if (needTip === false) {
        actions.push(getDiscardTipAction(step.definition.tip.discardItem));
      }

    // isolated_targets (necesita un viaje por cada target) o no alcanza un solo viaje para completar todos.
    } else {
      let needTip = true; // TODO may re-use tip from previous step?
      for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        // travels
        let transfered = 0;
        for (let t = 0; t < travelsForEachTarget; t++) {
          if (needTip) {
            actions.push(getPickTipAction(step.definition.tip.item));
          }
          const falta = volumeForEachTarget - transfered;
          let pic = tipVolume;
          if (falta >= tipVolume) {
            pic = tipVolume;
          } else {
            pic = falta;
          }
          console.log('falta', falta);
          console.log('pic', pic);
          const usingSource = getAvailableSourceAndUpdateIt(sources, pic);
          console.log(usingSource);
          if (!usingSource) {
            console.log('No source available to pick required liquid.');
            return false;
          }
          actions.push(getLoadLiquidAction(usingSource.s.item, 'name', usingSource.s.content.name, usingSource.v));

          transfered = transfered + usingSource.v;
          actions.push(getDropLiquidAction(target.item, 'name', target.content.name, usingSource.v));
          updateTargetVolume(target, usingSource.v);

          // drop tip?
          if (pippetingMode === 'isolated_source_only' || pippetingMode === 'isolated_targets') {
            actions.push(getDiscardTipAction(step.definition.tip.discardItem));
            needTip = true;
          } else {
            needTip = false;
          }
        } // end travels
      } // end target
      if (pippetingMode === 'reuse') {
        // drop the final tip
        actions.push(getDiscardTipAction(step.definition.tip.discardItem));
      }
    } // end pipeting normal

    actions.push(getCommentAction('End step: ' + step.name));
    return actions;
  }

  function buildSimplePippetinStepTreatEach (step) {
    const actions = [];
    // for each
    console.log('for_each');
    const sources = mainHelper.getContentsInWorkspace(workspace, step.definition.source.item, step.definition.source.by, step.definition.source.value);
    console.log('===sources', sources);
    if (!sources.length) {
      console.log('No matching sources in step.');
      return false;
    }
    const targets = mainHelper.getContentsInWorkspace(workspace, step.definition.target.item, step.definition.target.by, step.definition.target.value);
    console.log('===targets', targets);
    if (!targets.length) {
      console.log('No matching targets in step.');
      return false;
    }
    if (targets.length !== sources.length) {
      console.log('No matching 1:1 sources with targets in step.');
      return false;
    }
    if (!step.definition.volume || !step.definition.volume.type) {
      console.log('No volume type in step.');
      return false;
    }
    let volumeForEachTarget = step.definition.volume.value; // fixed_each
    if (step.definition.volume.type === 'for_each_target_tag') { // (for_each_target_with_tag)
      const volumeMultipler = mainHelper.getContentsInWorkspace(workspace, '', 'tag', step.definition.volume.tag).length;
      volumeForEachTarget = volumeMultipler * step.definition.volume.value;
    } else if (step.definition.volume.type === 'fixed_total') {
      volumeForEachTarget = step.definition.volume.value / targets.length;
    }

    const pippetingMode = step.definition.tip.mode;
    const tipVolume = mainHelper.getTipVolume(workspace, step.definition.tip.item);
    if (!tipVolume) {
      console.log('No max volume defined in tip rack.');
      return false;
    }
    const travelsForEachTarget = Math.ceil(volumeForEachTarget / tipVolume);
    console.log('==volumeForEachTarget==', volumeForEachTarget);
    console.log('==travelsForEachTarget==', travelsForEachTarget);

    let needTip = true;
    for (let i = 0; i < sources.length; i++) {
      const source = sources[i];
      let transfered = 0;
      for (let t = 0; t < travelsForEachTarget; t++) {
        if (needTip) {
          actions.push(getPickTipAction(step.definition.tip.item));
        }
        const falta = volumeForEachTarget - transfered;
        let pic = tipVolume;
        if (falta >= tipVolume) {
          pic = tipVolume;
        } else {
          pic = falta;
        }
        console.log('falta', falta);
        console.log('pic', pic);
        const usingSource = getAvailableSourceAndUpdateIt([source], pic);
        console.log(usingSource);
        if (!usingSource) {
          console.log('No source available to pick required liquid.');
          return false;
        }
        actions.push(getLoadLiquidAction(usingSource.s.item, 'name', usingSource.s.content.name, usingSource.v));

        transfered = transfered + usingSource.v;
        const reTag = computeReTag(step.definition, targets[i], usingSource.s);

        actions.push(getDropLiquidAction(targets[i].item, 'name', targets[i].content.name, usingSource.v, reTag));
        updateTargetVolume(targets[i], usingSource.v);
        // drop tip?
        if (pippetingMode === 'reuse_same_source' || pippetingMode === 'reuse') {
          needTip = false;
        } else {
          actions.push(getDiscardTipAction(step.definition.tip.discardItem));
          needTip = true;
        }
      } // end travels
      // change tip for next source?
      if (pippetingMode === 'reuse_same_source') {
        actions.push(getDiscardTipAction(step.definition.tip.discardItem));
        needTip = true;
      }
    } // end of loop sources
    if (pippetingMode === 'reuse') {
      // drop the final tip
      actions.push(getDiscardTipAction(step.definition.tip.discardItem));
    }
    actions.push(getCommentAction('End step: ' + step.name));
    return actions;
  }

  function buildMixStep (step) {
    console.log('step', step);
    const actions = [];

    if (!step.definition) {
      console.log('No definition in step.');
      return false;
    }
    if (!step.definition.target) {
      console.log('No target in definition.');
      return false;
    }
    if (!step.definition.mix) {
      console.log('No defined mix options.');
      return false;
    }
    if (!step.definition.mix.percentage) {
      console.log('No percentage defined in mix options.');
      return false;
    }
    if (!step.definition.mix.type) {
      console.log('No type defined in mix options.');
      return false;
    }
    if (!step.definition.mix.count) {
      console.log('No count defined in mix options.');
      return false;
    }

    const targets = mainHelper.getContentsInWorkspace(workspace, step.definition.target.item, step.definition.target.by, step.definition.target.value);
    console.log('===targets', targets);
    if (!targets.length) {
      console.log('No matching targets in step.');
      return false;
    }

    const pippetingMode = step.definition.tip.mode;
    const tipVolume = mainHelper.getTipVolume(workspace, step.definition.tip.item);
    if (!tipVolume) {
      console.log('No max volume defined in tip rack.');
      return false;
    }

    let needTip = true;
    for (let i = 0; i < targets.length; i++) {
      const target = targets[i];
      if (needTip) {
        actions.push(getPickTipAction(step.definition.tip.item));
      }
      actions.push(getMixAction(target.item, 'name', target.content.name, step.definition.mix.percentage, step.definition.mix.type, step.definition.mix.count));
      if (pippetingMode === 'reuse') {
        needTip = false;
      } else { // asume isolated_targets
        needTip = true;
        actions.push(getDiscardTipAction(step.definition.tip.discardItem));
      }
    }
    if (pippetingMode === 'reuse') {
      actions.push(getDiscardTipAction(step.definition.tip.discardItem));
    }
    actions.push(getCommentAction('End step: ' + step.name));
    return actions;
  }

  function buildWaitStep (step) {
    if (step && step.definition) {
      if ('seconds' in step.definition) {
        const seconds = parseInt(step.definition.seconds);
        if (isNaN(seconds)) {
          console.log('Invalid seconds');
          return false;
        }
        return [getWaitAction(seconds)];
      }
      console.log('No seconds in step definition.');
      return false;
    }
    console.log('No definition in step.');
    return false;
  }

  function buildHumanStep (step) {
    if (step && step.definition) {
      if ('text' in step.definition) {
        return [getHumanAction(step.definition.text)];
      }
      console.log('No text in step definition.');
      return false;
    }
    console.log('No definition in step.');
    return false;
  }

  function buildCommentStep (step) {
    if (step && step.definition) {
      if ('text' in step.definition) {
        return [getCommentAction(step.definition.text)];
      }
      console.log('No text in step definition.');
      return false;
    }
    console.log('No definition in step.');
    return false;
  }

  function getMixAction (itemName, by, value, percentage, of, count) {
    return {
      'cmd': 'PIPETTIN_PIX',
      'args': {
        'item': itemName,
        'selector': {
          by,
          value
        },
        'percentage': parseInt(percentage, 10),
        of,
        'count': parseInt(count, 10)
      }
    };
  }

  function getPickTipAction (itemName) {
    return {
      'cmd': 'PICK_TIP',
      'args': {
        'item': itemName
      }
    };
  }

  function getWaitAction (seconds) {
    return {
      'cmd': 'WAIT',
      'args': {
        seconds
      }
    };
  }

  function getHumanAction (text) {
    return {
      'cmd': 'HUMAN',
      'args': {
        text
      }
    };
  }

  function getLoadLiquidAction (itemName, by, value, volume) {
    return {
      'cmd': 'LOAD_LIQUID',
      'args': {
        'item': itemName,
        'selector': {
          by,
          value
        },
        volume
      }
    };
  }

  function getDropLiquidAction (itemName, by, value, volume, reTag) {
    const cmd = {
      'cmd': 'DROP_LIQUID',
      'args': {
        'item': itemName,
        'selector': {
          by,
          value
        },
        volume
      }
    };
    if (reTag) {
      cmd.args.addTag = reTag;
    }
    return cmd;
  }

  function getDiscardTipAction (itemName) {
    return {
      'cmd': 'DISCARD_TIP',
      'args': {
        'item': itemName
      }
    };
  }

  function getCommentAction (text) {
    return {
      'cmd': 'COMMENT',
      'args': {
        text
      }
    };
  }

  function getHomeAction () {
    return {
      'cmd': 'HOME'
    };
  }

  return {
    build
  };
}

module.exports = protocolBuilder;
